swift stackview サイズ 確保
https://ja.stackoverflow.com/questions/49671/vertical%E3%81%AAstackview%E3%81%AE%E4%B8%AD%E3%81%AB%E7%BD%AE%E3%81%84%E3%81%9Fview%E3%81%AE%E9%AB%98%E3%81%95%E3%82%92%E5%86%85%E5%81%B4%E3%81%AE%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E6%B1%BA%E5%AE%9A%E3%81%95%E3%81%9B%E3%81%9F%E3%81%84
オートレイアウトの解説が手厚い

UIImageView の Content Mode について
https://blog.officekoma.co.jp/2016/10/swiftuiimageviewcontentmode.html
ScaleAspectFit = *ImageViewのサイズ内で*、画像を元の比率のまま表示する
                 縦横比を維持したままImageViewに収まるように縮小する設定

The stackviews distribution should be set to fillProportionally so every arranged subview keeps its proportions.

However, the remaining space is filled by the stackview automatically. To suppress this, you need to add an empty view at the end. This empty view needs a low content hugging priority so it can grow to fill up the space where the other views remain by their proportions.

Furthermore, the empty view needs an intrinsicContentSize for the stackview to compute the dimensions:

class FillView: UIView {
    override var intrinsicContentSize: CGSize {
        get { return CGSize(width: 100, height: 100) }
    }
}
Now set your arranged subviews and put the fillView at the end

let fillView: UIFillView()
fillView.setContentHuggingPriority(priority: .fittingSizeLevel, for: .horizontal)
myStackView.addArrangedSubview(fillView)
Set the stackviews spacing to your needs to maintain the distance between the subviews.


https://stackoverflow.com/questions/31261546/dividing-screen-in-to-1-3-and-2-3-views-using-autolayout
fillProportionallyにしてから。
Make an "Equal widths" constraints between your view and the super view
with multiplier 2:3 for one view and 1:3 for the other.
See picture. "Equal height" if you want to split in the other direction.



import UIKit
import AVFoundation
import MediaPlayer

class ViewController: UIViewController {

    let engine = AVAudioEngine()

    override func viewDidLoad() {
        super.viewDidLoad()

        let mediaPicker = MPMediaPickerController(mediaTypes: .music)
        mediaPicker.allowsPickingMultipleItems = false
        mediaPicker.showsCloudItems = false // you won't be able to fetch the URL for media items stored in the cloud
        mediaPicker.delegate = self
        mediaPicker.prompt = "Pick a track"
        present(mediaPicker, animated: true, completion: nil)
    }

    func startEngine(playFileAt: URL) {
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)

            let avAudioFile = try AVAudioFile(forReading: playFileAt)
            let player = AVAudioPlayerNode()

            engine.attach(player)
            engine.connect(player, to: engine.mainMixerNode, format: avAudioFile.processingFormat)

            try engine.start()
            player.scheduleFile(avAudioFile, at: nil, completionHandler: nil)
            player.play()
        } catch {
            assertionFailure(String(describing: error))
        }
    }
}

extension ViewController: MPMediaPickerControllerDelegate {
    func mediaPicker(_ mediaPicker: MPMediaPickerController, didPickMediaItems mediaItemCollection: MPMediaItemCollection) {
        guard let item = mediaItemCollection.items.first else {
            print("no item")
            return
        }
        print("picking \(item.title!)")
        guard let url = item.assetURL else {
            return print("no url")
        }

        dismiss(animated: true) { [weak self] in
            self?.startEngine(playFileAt: url)
        }
    }

    func mediaPickerDidCancel(_ mediaPicker: MPMediaPickerController) {
        dismiss(animated: true, completion: nil)
    }
}
